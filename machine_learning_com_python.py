# -*- coding: utf-8 -*-
"""Machine_Learning_com_python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IIJEA0kdB-fH-2hfc9SKRifgG9i_bb--

# 1.1 - Algebra Linear em Python
"""

# algebra linear -> x + 2 = 5 =>> x = 3   (Resolver sistemas de equações lineares.)
# x + y = 10 (infinitas possibilidades de resolução)
# se x = 0 o y = 10
# se x = 2 o y = 8
# Equeação Diofantica

#x + y = 10
#2x+ y = 11 --->>

"""$$ \alpha + \beta = 10$$"""

import numpy as np
import scipy as sc
import sympy as sy
import pandas as pd
import matplotlib.pyplot as plt

# diferenças entre escalar, vetor e matriz
# Escalar é um número (Tensor de ordem 0)-->> x=2
x=2 #Escalar
#Vetor é uma estrutura unidimencional, precisa um plano (cartesiano) (tensor de ondem 1)
#matriz é um plano tridimencional,
x2 = np.array([1,2,3]) # vetor com três elementos escalares
x3 = np.array([[1],[2],[3]]) # Matriz(coluna) com 3 elementos vetores com elementos escalares
x4 = np.array([[1,2,3],[1,2,3],[1,2,3]]) # Matriz quadrada tradicional
print(x2)
print()
print(x3)
print()
print(x4)

lista = [1,2,3,4,5]
#df = pd.DataFrame(lista)  -> irá criar um DataFrame com Index 0
df = pd.DataFrame({'coluna1':lista, 'coluna2':lista})   #-> vai criar com o index coluna 1 {} -> dicionário
df

type(df.coluna1)    #->cada coluna é uma array que é igual a series

lista[:1]

x2+x3   #->combinação linear (somatorio de elementos multiplicados entre si)

# Multiplicar

# arr1 (x,y) arr2 (z,w)  ---> y = z  / arr3 (x, w)
#np.dot ou @
#a.b != b.a
np.dot(x4, x3)

x4@x3

#divisão

#2.x = 4 ---> x=4/2
#>> A.X = Y  ----->> Equação Fundamental da Algebra Linear
x4 / x3

"""#1.1.1 Matrizes Especiais"""

'''
Para os Escalares,
O zero é um elementro neutro para a soma  e subtração
o Um é um elemento neutro na multiplicação e divisão
'''

zeros=np.zeros((3,3))
ones=np.ones((3,3))
print(zeros)
print()
print(ones)

"""#1.1.2 Matrizes Inversas (Matriz Quadrada)"""

x4

"""$$A = \pmatrix{a_{00} & a_{01} & a_{02}\\ a_{10} & a_{11} & a_{12}\\a_{20} & a_{21} & a_{22}}
$$
"""

id = np.eye(3)
id

x4*id

"""$$x  .  x^{-1}  =  1$$

-------
$$Matriz Inversa$$
$$A  .  A^{-1}  =  I -->>> Somente em matrizes quadradas.$$

-----

$$Equação Fundamental da Algebra $$

$$A . X = Y--> Fundamento$$
$$A . A^{-1}.X = A^{-1}. Y--> Multiplica nos dois lados$$
 $$ X = A^{-1} . Y    -->REsultado$$ $$--> Se A for uma matriz quadrada$$
"""

'''
Um número multiplicado pelo se uinverso deve ter o resultado 1
o numero 2, o seu inverso é 1/2
2 * 1/2 = 1
'''

'''
Uma MAtriz multiplicada pelo seu inverso deve gerar uma matriz identidade.
MAtriz A
'''

"""# 1.1.3 Matrizes Pseudo Inversas (não Quadradas)

$$Matrizes Pseudo Inversas$$
$$X = (A.^{T}A)^{-1}A^{T}.Y ---> T = Matriz Transposta$$
"""

x1,y1 = -1,0
x2,y2 = 0,1
x3,y3 = 1,2
x4,y4 = 2,1

x = [x1,x2,x3,x4]
y = [y1,y2,y3,y4]

plt.figure(figsize=(10,5))

plt.scatter(x1,y1, color='green', label='Pares Ordenados (X,Y)')
plt.scatter(x2,y2, color='green')
plt.scatter(x3,y3, color='green')
plt.scatter(x4,y4, color='green')

plt.plot(x,y, label='Gráfico que liga os Pontos')
plt.grid(True)
plt.box(False)
plt.legend()
plt.title('Interpolação da Reta Sobre Todos os Pontos')

#y = mx + n
#0 = -m + n
A = np.array([[-1,1], [0,1], [1,1], [2,1]])
y = np.array([[y1], [y2], [y3], [y4]])

(m,n) = np.dot(np.dot(np.linalg.pinv(np.dot(A.T,A)),A.T),y) # -->X=(A.TA)−1AT.Y

print(m,n)

x1,y1 = -1,0
x2,y2 = 0,1
x3,y3 = 1,2
x4,y4 = 2,1

x = [x1,x2,x3,x4]
y = [y1,y2,y3,y4]

plt.figure(figsize=(10,5))

plt.scatter(x1,y1, color='green', label='Pares Ordenados (X,Y)')
plt.scatter(x2,y2, color='green')
plt.scatter(x3,y3, color='green')
plt.scatter(x4,y4, color='green')

v_x=np.linspace(-1,2)
plt.plot(x,y, label='Gráfico que liga os Pontos')
plt.plot(v_x, m*v_x+n, label='Reta Otimizada pelo Método dos Minimos Quadrados')
plt.grid(True)
plt.box(False)
plt.legend()
plt.title('Interpolação da Reta Sobre Todos os Pontos')

"""# 1.2 Estatística em Python"""



"""# 1.3 Os Primeiros passos em Machine Learning"""

import pandas as pd

df_excel = pd.read_excel("Chess.xlsx", sheet_name = "Chess")

df_csv = pd.read_csv("Tomato.csv", sep = ",")

df_excel.shape

df_csv.shape

df_excel.info()

df_csv.info()

df_csv.tail()

df_excel.tail()

df_excel.describe()

df_csv.describe()

df_excel.describe().T

df_csv.describe().T

df_excel.head()

#visualizar a variaçãos das categorias de dados.
set(df_excel["victory_status"])

df_csv.head()

# a coluna Average mostra a medida minima e máxima do tomate para a função
df_csv.describe()

def categorizar_tomate_media(media):
  if media >= 40 and media <= 70:
    return "tomate medio"
  elif media < 40:
    return "tomate pequeno"
  else:
    return "tomatão"

df_csv["Categoria_Tomate"] = df_csv["Average"].apply(categorizar_tomate_media)

df_csv

df_csv.groupby(["Categoria_Tomate"]).describe()

filtro = df_csv["Average"] < 40
df_csv.loc[filtro]

"""#1.4 Numpy"""

import numpy as np

arr_list = np.array([1, 2, 3, 4, 5, 6, 7, 8])

print(arr_list)

arr_zeros = np.zeros((4, 6))
print(arr_zeros)

arr_ones = np.ones((3, 4))
print(arr_ones)

arr_random = np.random.rand(3, 4)
print(arr_random)

print(arr_random.shape)

arr_random_reshape = arr_random.reshape((4,3))
print(arr_random_reshape)

arr1 = np.array([[1,2], [3,4]])
arr2 = np.array([[5,6], [7,8]])
arr3 = np.array([[9,10], [11,12]])

arr4 = np.concatenate((arr1, arr2, arr3), axis=1)

arr4

arr4_split = np.split(arr4, 2)
arr4_split

arr4_transpose = np.transpose(arr4)
print(arr4_transpose)

arr4_revertido = arr4_transpose.T
print(arr4_revertido)

arr_a = np.array([1,7,27])
arr_b = np.array([1,5,1])

arr_a_b = np.add(arr_a, arr_b)
arr_a_b

arr_sub_a_b = np.subtract(arr_a, arr_b)
arr_sub_a_b

"""#1.5 MatPlotLib"""

import matplotlib.pyplot as plt

df_csv.head()

df_csv.info()

df_csv["Date"] = pd.to_datetime(df_csv["Date"])

df_csv.info()

plt.plot(df_csv["Date"], df_csv["Average"])
plt.xlabel("Data")
plt.ylabel("Média em kilos de Tomates")
plt.title("Média de Tomates ao Longo do Tempo")
plt.show()

df_excel.head()

plt.scatter(df_excel["black_rating"], df_excel["white_rating"])
plt.xlabel("Black")
plt.ylabel("White")
plt.title("Partidas de Peças Brancas e Peças Pretas")
plt.show()

plt.bar(df_csv["Categoria_Tomate"], df_csv["Average"])
plt.xlabel("Categorias de Tomates")
plt.ylabel("Média de Tamanho de Tomates")
plt.title("Médias de Tomates por Categorias")
plt.show()

df_excel.groupby(["victory_status"]).mean().plot(kind="pie", y="turns", autopct="%1.0f%%")
plt.title("Média de Partidas Dentro de Estatus de Vitória")
plt.show()

"""#1.6 Scikit-Learn"""

df_diabetes = pd.read_csv("/content/diabetes.csv", sep = ",")
df_diabetes

from sklearn.model_selection import train_test_split

x = df_diabetes.drop(["Class variable"], axis=1)

x

y = df_diabetes["Class variable"]

y

x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.3)
#30% para teste e o restante para treino

x_train
#70% para treino

x_test
#30% para teste

y_train
#70% para o treino pegando a mesma base para comparação

y_test
#30% para test pegando a mesma base para comparação

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=3)

knn.fit(x_train, y_train)

accuracy = knn.score(x_test, y_test)

accuracy

"""#2 EDA - Exploration Data Analisys"""

df_rs = pd.read_excel("/content/dataset_rolling_stones.xlsx")
df_rs

print("Data Inicial:", df_rs["release_date"].min())

print("Data Final:", df_rs["release_date"].max())

df_rs.isnull().sum()

df_rs.duplicated().sum()

df_rs[df_rs.duplicated()]

df_rs.describe()

df_rs["duração_em_min"] = df_rs["duration_ms"]/60000
df_rs

df_rs.describe()

media_por_album = df_rs.groupby("album")["duração_em_min"].mean()
media_por_album

import matplotlib.pyplot as plt

df_maior_duracao = df_rs.groupby("album")["duração_em_min"].mean().sort_values(ascending=False)
df_maior_duracao

df_maior_duracao.head(25).plot(kind="bar")
plt.xlabel("Albuns")
plt.ylabel("Tempo")
plt.title("Albuns com maior duração média por musica")

top_albuns = df_rs["album"].value_counts().head(10)
plt.barh(top_albuns.index, top_albuns.values)
plt.title("Top 10 albuns com maior número de músicas")
plt.show()

df_rs.info()

df_rs_ultima_decada = df_rs[df_rs["release_date"].between(pd.to_datetime("2011"), pd.to_datetime("2022"))]
df_rs_ultima_decada

df_por_album = df_rs_ultima_decada.groupby("album")["popularity"].sum().sort_values(ascending=False).head(10)
df_por_album

total_popularidade = df_por_album.sum()
df_porcentagem = df_por_album / total_popularidade*100
labels = df_porcentagem.index.tolist()
sizes = df_porcentagem.values.tolist()

figura,grafico = plt.subplots(figsize = (18,6))
grafico.pie(sizes, autopct = "%1.1f%%")
grafico.axis('equal')
plt.title("Porcentagem de Popularidade de albuns na última Década")
plt.legend(labels, loc="best")
plt.show()

